name: Promote to Production

# NOTE: Tests are currently skipped in the staging deployment workflow
# Production deployments inherit from staging builds without test validation

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      staging_commit:
        description: 'Commit SHA from staging to promote (leave empty for latest)'
        required: false
        type: string
      skip_validation:
        description: 'Skip staging validation checks'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: eu-west-2
  STAGING_INSTANCE_TAG: ai-trading-bot-staging
  PRODUCTION_INSTANCE_TAG: ai-trading-bot-production
  STAGING_SECRETS_NAME: ai-trading-bot/staging
  PRODUCTION_SECRETS_NAME: ai-trading-bot/production
  S3_BUCKET: ai-trading-bot-storage

jobs:
  validate-staging:
    name: Validate Staging Environment
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_validation }}
    outputs:
      staging-healthy: ${{ steps.health-check.outputs.healthy }}
      staging-commit: ${{ steps.get-commit.outputs.commit }}
      
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get staging deployment info
      id: get-commit
      run: |
        if [ -n "${{ inputs.staging_commit }}" ]; then
          COMMIT_SHA="${{ inputs.staging_commit }}"
          echo "Using specified commit: $COMMIT_SHA"
        else
          # Get latest deployment from S3
          DEPLOYMENT_INFO=$(aws s3 cp s3://${{ env.S3_BUCKET }}/deployments/staging/latest-deployment.json - 2>/dev/null || echo '{}')
          COMMIT_SHA=$(echo "$DEPLOYMENT_INFO" | jq -r '.commit // "unknown"')
          
          if [ "$COMMIT_SHA" = "unknown" ] || [ "$COMMIT_SHA" = "null" ]; then
            echo "❌ Cannot determine staging commit. Please specify manually."
            exit 1
          fi
          echo "Latest staging commit: $COMMIT_SHA"
        fi
        
        echo "commit=$COMMIT_SHA" >> $GITHUB_OUTPUT
        
    - name: Find staging instance
      id: find-staging
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.STAGING_INSTANCE_TAG }}" \
                   "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
          
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "❌ No running staging instance found"
          exit 1
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "✅ Found staging instance: $INSTANCE_ID"
        
    - name: Validate staging health
      id: health-check
      run: |
        echo "🔍 Checking staging environment health..."
        
        # Check if service is running
        aws ssm send-command \
          --instance-ids ${{ steps.find-staging.outputs.instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["systemctl is-active ai-trading-bot","journalctl -u ai-trading-bot -n 10 --no-pager"]' \
          --output text \
          --query 'Command.CommandId' > health-command-id.txt
          
        HEALTH_COMMAND_ID=$(cat health-command-id.txt)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id $HEALTH_COMMAND_ID \
          --instance-id ${{ steps.find-staging.outputs.instance-id }}
          
        # Check results
        COMMAND_STATUS=$(aws ssm get-command-invocation \
          --command-id $HEALTH_COMMAND_ID \
          --instance-id ${{ steps.find-staging.outputs.instance-id }} \
          --query 'Status' \
          --output text)
          
        if [ "$COMMAND_STATUS" = "Success" ]; then
          echo "✅ Staging environment is healthy"
          echo "healthy=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Staging environment health check failed"
          aws ssm get-command-invocation \
            --command-id $HEALTH_COMMAND_ID \
            --instance-id ${{ steps.find-staging.outputs.instance-id }} \
            --query 'StandardOutputContent' \
            --output text
          echo "healthy=false" >> $GITHUB_OUTPUT
          exit 1
        fi

  prepare-production:
    name: Prepare Production Deployment
    runs-on: ubuntu-latest
    needs: [validate-staging]
    if: ${{ always() && (needs.validate-staging.result == 'success' || inputs.skip_validation) }}
    environment: production  # Requires manual approval
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Create production deployment package
      run: |
        echo "📦 Creating production deployment package..."
        
        # Create deployment package (same as staging but with production config)
        mkdir -p deployment-package
        
        rsync -av --exclude-from=.gitignore \
          --exclude='.git*' \
          --exclude='*.pyc' \
          --exclude='__pycache__' \
          --exclude='.pytest_cache' \
          --exclude='.coverage' \
          --exclude='htmlcov' \
          --exclude='.venv' \
          --exclude='staging' \
          --exclude='model_backups' \
          --exclude='*.log' \
          --exclude='*.tmp' \
          --exclude='.DS_Store' \
          --exclude='Thumbs.db' \
          . deployment-package/
          
        # Create version info
        echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> deployment-package/VERSION
        echo "COMMIT_SHA=${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}" >> deployment-package/VERSION
        echo "BRANCH=${{ github.ref_name }}" >> deployment-package/VERSION
        echo "ENVIRONMENT=production" >> deployment-package/VERSION
        echo "PROMOTED_FROM=staging" >> deployment-package/VERSION
        
        # Create deployment archive
        tar -czf ai-trading-bot-production.tar.gz -C deployment-package .
        
    - name: Upload production deployment package
      run: |
        COMMIT_SHA="${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}"
        
        # Upload deployment package to S3
        aws s3 cp ai-trading-bot-production.tar.gz \
          s3://${{ env.S3_BUCKET }}/deployments/production/ai-trading-bot-${COMMIT_SHA}.tar.gz
        
        # Upload deployment script to S3 as well
        aws s3 cp bin/deploy-production.sh \
          s3://${{ env.S3_BUCKET }}/scripts/deploy-production-${COMMIT_SHA}.sh
        
        echo "✅ Production deployment package and script uploaded"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate-staging, prepare-production]
    environment: production
    timeout-minutes: 45  # Longer timeout for production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Find production instance
      id: find-production
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.PRODUCTION_INSTANCE_TAG }}" \
                   "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
          
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "❌ No running production instance found with tag: ${{ env.PRODUCTION_INSTANCE_TAG }}"
          exit 1
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "✅ Found production instance: $INSTANCE_ID"
        
    - name: Pre-deployment backup
      run: |
        echo "💾 Creating pre-deployment backup..."
        
        # Create backup via SSM
        aws ssm send-command \
          --instance-ids ${{ steps.find-production.outputs.instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["cd /opt/ai-trading-bot && sudo tar -czf /opt/ai-trading-bot-pre-deploy-backup-$(date +%Y%m%d_%H%M%S).tar.gz . && echo \"Backup created\""]' \
          --output text \
          --query 'Command.CommandId' > backup-command-id.txt
          
        BACKUP_COMMAND_ID=$(cat backup-command-id.txt)
        
        aws ssm wait command-executed \
          --command-id $BACKUP_COMMAND_ID \
          --instance-id ${{ steps.find-production.outputs.instance-id }}
          
        echo "✅ Pre-deployment backup completed"
        
    - name: Deploy to production
      run: |
        COMMIT_SHA="${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}"
        
        # Execute production deployment via AWS Systems Manager
        aws ssm send-command \
          --instance-ids ${{ steps.find-production.outputs.instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"aws s3 cp s3://${{ env.S3_BUCKET }}/scripts/deploy-production-${COMMIT_SHA}.sh /tmp/deploy.sh && chmod +x /tmp/deploy.sh && /tmp/deploy.sh ${COMMIT_SHA} ${{ env.S3_BUCKET }}\"]" \
          --output text \
          --query 'Command.CommandId' > production-command-id.txt
          
        PRODUCTION_COMMAND_ID=$(cat production-command-id.txt)
        echo "📡 Production deployment command sent: $PRODUCTION_COMMAND_ID"
        
        # Wait for deployment to complete (longer timeout for production)
        echo "⏳ Waiting for production deployment to complete..."
        timeout 1800 aws ssm wait command-executed \
          --command-id $PRODUCTION_COMMAND_ID \
          --instance-id ${{ steps.find-production.outputs.instance-id }} || {
          echo "❌ Production deployment timed out after 30 minutes"
          exit 1
        }
        
        # Check deployment result
        COMMAND_STATUS=$(aws ssm get-command-invocation \
          --command-id $PRODUCTION_COMMAND_ID \
          --instance-id ${{ steps.find-production.outputs.instance-id }} \
          --query 'Status' \
          --output text)
          
        if [ "$COMMAND_STATUS" = "Success" ]; then
          echo "✅ Production deployment completed successfully"
        else
          echo "❌ Production deployment failed with status: $COMMAND_STATUS"
          echo "📋 Error output:"
          aws ssm get-command-invocation \
            --command-id $PRODUCTION_COMMAND_ID \
            --instance-id ${{ steps.find-production.outputs.instance-id }} \
            --query 'StandardErrorContent' \
            --output text
          echo "📋 Standard output:"
          aws ssm get-command-invocation \
            --command-id $PRODUCTION_COMMAND_ID \
            --instance-id ${{ steps.find-production.outputs.instance-id }} \
            --query 'StandardOutputContent' \
            --output text
          exit 1
        fi

    - name: Post-deployment verification
      run: |
        echo "🔍 Performing post-deployment verification..."
        
        # Extended health check for production
        aws ssm send-command \
          --instance-ids ${{ steps.find-production.outputs.instance-id }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["systemctl is-active ai-trading-bot","systemctl status ai-trading-bot --no-pager","journalctl -u ai-trading-bot -n 10 --no-pager"]' \
          --output text \
          --query 'Command.CommandId' > verify-command-id.txt
          
        VERIFY_COMMAND_ID=$(cat verify-command-id.txt)
        
        aws ssm wait command-executed \
          --command-id $VERIFY_COMMAND_ID \
          --instance-id ${{ steps.find-production.outputs.instance-id }}
          
        echo "📋 Production service status:"
        aws ssm get-command-invocation \
          --command-id $VERIFY_COMMAND_ID \
          --instance-id ${{ steps.find-production.outputs.instance-id }} \
          --query 'StandardOutputContent' \
          --output text
          
    - name: Record production deployment
      if: always()
      run: |
        COMMIT_SHA="${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}"
        DEPLOYMENT_STATUS="${{ job.status }}"
        
        if [ "$DEPLOYMENT_STATUS" = "success" ]; then
          echo "📝 Recording successful production deployment"
          STATUS_MESSAGE="success"
        else
          echo "📝 Recording failed production deployment"
          STATUS_MESSAGE="failed"
        fi
        
        # Record deployment in S3
        echo "{\"status\":\"$STATUS_MESSAGE\",\"commit\":\"$COMMIT_SHA\",\"timestamp\":\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\",\"branch\":\"${{ github.ref_name }}\",\"author\":\"${{ github.actor }}\",\"promoted_from\":\"staging\"}" | \
          aws s3 cp - s3://${{ env.S3_BUCKET }}/deployments/production/latest-deployment.json
        
        echo "✅ Production deployment status recorded"

    - name: Cleanup temporary files
      if: always()
      run: |
        COMMIT_SHA="${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}"
        # Clean up temporary script from S3
        aws s3 rm s3://${{ env.S3_BUCKET }}/scripts/deploy-production-${COMMIT_SHA}.sh || echo "Script already cleaned up"
        echo "🧹 Temporary files cleaned up"

    - name: Create GitHub deployment status
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const commitSha = '${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}';
          
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: commitSha,
            environment: 'production',
            description: 'Production deployment via promotion from staging',
            auto_merge: false
          });
          
          const deploymentStatus = '${{ job.status }}' === 'success' ? 'success' : 'failure';
          const description = '${{ job.status }}' === 'success' ? 'Production deployment successful' : 'Production deployment failed';
          
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: deployment.data.id,
            state: deploymentStatus,
            description: description,
            environment_url: 'https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Instances:tag:Name=${{ env.PRODUCTION_INSTANCE_TAG }}'
          });

  notify-completion:
    name: Notify Deployment Completion
    runs-on: ubuntu-latest
    needs: [validate-staging, deploy-production]
    if: always()
    
    steps:
    - name: Deployment Summary
      run: |
        echo "🎯 Production Promotion Summary"
        echo "=============================="
        echo "Staging Validation: ${{ needs.validate-staging.result }}"
        echo "Production Deployment: ${{ needs.deploy-production.result }}"
        echo "Commit: ${{ needs.validate-staging.outputs.staging-commit || inputs.staging_commit || github.sha }}"
        echo "Triggered by: ${{ github.actor }}"
        echo "Timestamp: $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
        
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "✅ Production promotion completed successfully!"
          echo "⚠️  Please monitor the production environment closely"
        else
          echo "❌ Production promotion failed!"
          echo "🔧 Check the logs and consider rollback if necessary"
        fi
