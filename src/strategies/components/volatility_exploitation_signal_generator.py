"""
Volatility Exploitation Signal Generator

This signal generator identifies and exploits high volatility environments
where rapid price movements create trading opportunities. It increases
trading frequency and position sizes during volatile periods.

Volatility Trading Philosophy:
- High volatility = High opportunity (larger moves to capture)
- High volatility = High risk (use wider stops, smaller base sizes)
- Volatility mean reversion (high volatility doesn't last forever)
- Profit from both volatility expansion AND contraction

Key Indicators:
1. ATR (Average True Range) - Absolute volatility measurement
2. Bollinger Band Width - Relative volatility measurement
3. Historical Volatility - Standard deviation of returns
4. Volatility Percentile - Current vol vs historical range

Trading Logic:
- EXPANDING volatility: Enter momentum trades with wider stops
- HIGH volatility: Trade more frequently, take quicker profits
- CONTRACTING volatility: Reduce position sizes, prepare for breakout
- LOW volatility: Minimal trading, wait for volatility expansion
"""

from typing import Optional, Sequence

import numpy as np
import pandas as pd

from .signal_generator import Signal, SignalDirection, SignalGenerator
from .regime_context import RegimeContext, VolLabel


class VolatilityExploitationSignalGenerator(SignalGenerator):
    """
    Generate signals that exploit volatility conditions

    This generator adapts trading behavior based on current volatility,
    trading more aggressively in high volatility and conservatively in low.
    """

    def __init__(
        self,
        name: str = "volatility_exploitation_signals",
        # ATR parameters
        atr_period: int = 14,
        atr_high_threshold: float = 2.0,  # 2x average = high volatility
        atr_low_threshold: float = 0.5,  # 0.5x average = low volatility
        # Bollinger Band parameters
        bb_period: int = 20,
        bb_std_dev: float = 2.0,
        bb_width_high: float = 0.20,  # 20% width = high volatility
        bb_width_low: float = 0.05,  # 5% width = low volatility
        # Historical volatility parameters
        hvol_period: int = 20,
        hvol_percentile_period: int = 100,
        # Momentum parameters (for directional bias)
        momentum_period: int = 10,
        # Signal thresholds
        min_confidence: float = 0.55,
    ):
        """
        Initialize volatility exploitation signal generator

        Args:
            name: Signal generator name
            atr_period: ATR calculation period
            atr_high_threshold: ATR ratio for high volatility
            atr_low_threshold: ATR ratio for low volatility
            bb_period: Bollinger Band calculation period
            bb_std_dev: Bollinger Band standard deviations
            bb_width_high: BB width threshold for high volatility
            bb_width_low: BB width threshold for low volatility
            hvol_period: Historical volatility period
            hvol_percentile_period: Period for volatility percentile
            momentum_period: Momentum calculation period
            min_confidence: Minimum confidence for signal generation
        """
        super().__init__(name)
        self.atr_period = atr_period
        self.atr_high_threshold = atr_high_threshold
        self.atr_low_threshold = atr_low_threshold
        self.bb_period = bb_period
        self.bb_std_dev = bb_std_dev
        self.bb_width_high = bb_width_high
        self.bb_width_low = bb_width_low
        self.hvol_period = hvol_period
        self.hvol_percentile_period = hvol_percentile_period
        self.momentum_period = momentum_period
        self.min_confidence = min_confidence

    @property
    def warmup_period(self) -> int:
        """Return minimum history required"""
        return max(self.hvol_percentile_period, self.bb_period, self.atr_period) + 10

    def generate_signal(
        self, df: pd.DataFrame, index: int, regime: Optional[RegimeContext] = None
    ) -> Signal:
        """
        Generate volatility-exploitation signal

        Signal Logic:
        1. HIGH VOLATILITY + UPWARD MOMENTUM → BUY (ride the wave)
        2. HIGH VOLATILITY + DOWNWARD MOMENTUM → SELL (exit before collapse)
        3. LOW VOLATILITY + BREAKOUT SETUP → BUY (anticipate expansion)
        4. MEDIUM VOLATILITY → HOLD (wait for clear conditions)

        Args:
            df: DataFrame with OHLCV data
            index: Current candle index
            regime: Optional regime context

        Returns:
            Signal with volatility context
        """
        self.validate_inputs(df, index)

        # Calculate volatility metrics
        vol_metrics = self._calculate_volatility_metrics(df, index)

        # Determine volatility state
        vol_state = self._classify_volatility_state(vol_metrics)

        # Calculate momentum for directional bias
        momentum = self._calculate_momentum(df, index)

        # Generate signal based on volatility state and momentum
        direction, strength, confidence = self._generate_volatility_signal(
            vol_state, vol_metrics, momentum, df, index
        )

        return Signal(
            direction=direction,
            strength=strength,
            confidence=confidence,
            metadata={
                "generator": self.name,
                "index": index,
                "volatility_state": vol_state,
                "atr_ratio": vol_metrics["atr_ratio"],
                "bb_width": vol_metrics["bb_width"],
                "hvol_percentile": vol_metrics["hvol_percentile"],
                "momentum": momentum,
                "price_position": vol_metrics["price_position"],
            },
        )

    def get_confidence(self, df: pd.DataFrame, index: int) -> float:
        """Get confidence based on volatility clarity"""
        self.validate_inputs(df, index)
        vol_metrics = self._calculate_volatility_metrics(df, index)
        vol_state = self._classify_volatility_state(vol_metrics)

        # High/Low volatility = clear conditions = high confidence
        if vol_state in ["HIGH", "LOW"]:
            return 0.75
        elif vol_state in ["EXPANDING", "CONTRACTING"]:
            return 0.65
        else:
            return 0.50

    def _calculate_volatility_metrics(self, df: pd.DataFrame, index: int) -> dict:
        """Calculate all volatility indicators"""
        # ATR and ratio
        current_atr = self._calculate_atr(df, index, self.atr_period)
        avg_atr = self._calculate_atr(df, index - self.atr_period, self.atr_period * 2)
        atr_ratio = current_atr / avg_atr if avg_atr > 0 else 1.0

        # Bollinger Bands
        bb_middle, bb_upper, bb_lower, bb_width = self._calculate_bollinger_bands(df, index)
        price_position = self._calculate_bb_position(df, index, bb_middle, bb_upper, bb_lower)

        # Historical volatility
        hvol = self._calculate_historical_volatility(df, index)
        hvol_percentile = self._calculate_volatility_percentile(df, index, hvol)

        return {
            "atr_ratio": atr_ratio,
            "current_atr": current_atr,
            "bb_width": bb_width,
            "bb_middle": bb_middle,
            "bb_upper": bb_upper,
            "bb_lower": bb_lower,
            "price_position": price_position,
            "hvol": hvol,
            "hvol_percentile": hvol_percentile,
        }

    def _classify_volatility_state(self, vol_metrics: dict) -> str:
        """
        Classify current volatility state

        States:
        - HIGH: High volatility (trade more, wider stops)
        - LOW: Low volatility (trade less, tighter stops)
        - EXPANDING: Volatility increasing (enter momentum)
        - CONTRACTING: Volatility decreasing (reduce exposure)
        - MEDIUM: Normal volatility (standard approach)
        """
        atr_ratio = vol_metrics["atr_ratio"]
        bb_width = vol_metrics["bb_width"]
        hvol_percentile = vol_metrics["hvol_percentile"]

        # High volatility
        if atr_ratio > self.atr_high_threshold or bb_width > self.bb_width_high:
            return "HIGH"

        # Low volatility
        if atr_ratio < self.atr_low_threshold or bb_width < self.bb_width_low:
            return "LOW"

        # Expanding volatility (ATR increasing, percentile high)
        if atr_ratio > 1.2 and hvol_percentile > 0.70:
            return "EXPANDING"

        # Contracting volatility (ATR decreasing, percentile low)
        if atr_ratio < 0.8 and hvol_percentile < 0.30:
            return "CONTRACTING"

        # Medium/Normal volatility
        return "MEDIUM"

    def _generate_volatility_signal(
        self, vol_state: str, vol_metrics: dict, momentum: float, df: pd.DataFrame, index: int
    ) -> tuple[SignalDirection, float, float]:
        """Generate signal based on volatility state"""

        if vol_state == "HIGH":
            # High volatility: Trade with momentum
            if momentum > 0.02:  # 2% positive momentum
                return SignalDirection.BUY, 0.8, 0.75
            elif momentum < -0.02:  # 2% negative momentum
                return SignalDirection.SELL, 0.8, 0.75
            else:
                return SignalDirection.HOLD, 0.0, 0.5

        elif vol_state == "EXPANDING":
            # Expanding volatility: Enter momentum trades early
            if momentum > 0.01:
                return SignalDirection.BUY, 0.75, 0.70
            elif momentum < -0.01:
                return SignalDirection.SELL, 0.75, 0.70
            else:
                return SignalDirection.HOLD, 0.0, 0.5

        elif vol_state == "LOW":
            # Low volatility: Wait for breakout or reduce exposure
            # Check if price is at BB extremes (potential breakout)
            price_position = vol_metrics["price_position"]
            if price_position > 0.9:  # Near upper band
                return SignalDirection.BUY, 0.6, 0.65
            elif price_position < 0.1:  # Near lower band
                return SignalDirection.SELL, 0.6, 0.65
            else:
                return SignalDirection.HOLD, 0.0, 0.5

        elif vol_state == "CONTRACTING":
            # Contracting volatility: Reduce exposure, take profits
            if momentum < -0.015:  # Exit on weakness
                return SignalDirection.SELL, 0.7, 0.65
            else:
                return SignalDirection.HOLD, 0.0, 0.5

        else:  # MEDIUM
            # Medium volatility: Standard momentum approach
            if momentum > 0.03:
                return SignalDirection.BUY, 0.65, 0.60
            elif momentum < -0.03:
                return SignalDirection.SELL, 0.65, 0.60
            else:
                return SignalDirection.HOLD, 0.0, 0.5

    def _calculate_atr(self, df: pd.DataFrame, index: int, period: int) -> float:
        """Calculate Average True Range"""
        if index < period:
            return 0.0

        high = df["high"].iloc[max(0, index - period) : index + 1].values
        low = df["low"].iloc[max(0, index - period) : index + 1].values
        close = df["close"].iloc[max(0, index - period) : index + 1].values

        tr1 = high[1:] - low[1:]
        tr2 = np.abs(high[1:] - close[:-1])
        tr3 = np.abs(low[1:] - close[:-1])
        tr = np.maximum(tr1, np.maximum(tr2, tr3))

        return np.mean(tr)

    def _calculate_bollinger_bands(
        self, df: pd.DataFrame, index: int
    ) -> tuple[float, float, float, float]:
        """Calculate Bollinger Bands"""
        if index < self.bb_period:
            price = df["close"].iloc[index]
            return price, price, price, 0.0

        close = df["close"].iloc[max(0, index - self.bb_period) : index + 1].values
        middle = np.mean(close)
        std = np.std(close)
        upper = middle + (self.bb_std_dev * std)
        lower = middle - (self.bb_std_dev * std)
        width = (upper - lower) / middle if middle > 0 else 0.0

        return middle, upper, lower, width

    def _calculate_bb_position(
        self, df: pd.DataFrame, index: int, middle: float, upper: float, lower: float
    ) -> float:
        """Calculate price position within Bollinger Bands (0-1)"""
        price = df["close"].iloc[index]
        if upper == lower:
            return 0.5
        position = (price - lower) / (upper - lower)
        return max(0.0, min(1.0, position))

    def _calculate_historical_volatility(self, df: pd.DataFrame, index: int) -> float:
        """Calculate historical volatility (annualized std dev of returns)"""
        if index < self.hvol_period:
            return 0.0

        close = df["close"].iloc[max(0, index - self.hvol_period) : index + 1].values
        returns = np.diff(close) / close[:-1]
        std_dev = np.std(returns)

        # Annualize (assuming daily data, adjust if needed)
        annualized_vol = std_dev * np.sqrt(365)
        return annualized_vol

    def _calculate_volatility_percentile(
        self, df: pd.DataFrame, index: int, current_hvol: float
    ) -> float:
        """Calculate percentile rank of current volatility"""
        if index < self.hvol_percentile_period:
            return 0.5

        # Calculate hvol for each point in lookback
        hvols = []
        for i in range(max(0, index - self.hvol_percentile_period), index):
            hvol = self._calculate_historical_volatility(df, i)
            hvols.append(hvol)

        if not hvols:
            return 0.5

        # Calculate percentile rank
        percentile = sum(1 for v in hvols if v < current_hvol) / len(hvols)
        return percentile

    def _calculate_momentum(self, df: pd.DataFrame, index: int) -> float:
        """Calculate price momentum"""
        if index < self.momentum_period:
            return 0.0

        current_price = df["close"].iloc[index]
        past_price = df["close"].iloc[index - self.momentum_period]

        if past_price == 0:
            return 0.0

        return (current_price - past_price) / past_price

    def get_feature_generators(self) -> Sequence:
        """No additional features required"""
        return []
